<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Tetris</title>
        <style>
            table {
                /* tetris field table should have a ratio 2:1 */
                border: 1px solid black;
                width: 300px;
                height: 600px;
                empty-cells: show;
            }
        </style>
    </head>
    <body>
        <h1>Tetris</h1>
        <!-- empty table, this will be the tetris field -->
        <table id="tetris"></table>

        <script>
            // constants
            const nr_rows = 20;
            const nr_columns = 10;
            const tetris_table = document.getElementById("tetris");
            let drop_speed = 1000;

            // field
            let field = {
                field: [],

                spawn: function() {
                    // add empty rows and cells to the field matrix
                    for (let i = 0; i < nr_rows; i++) {
                        field.field[i] = new Array(nr_columns);
                    }
                    // add field to DOM
                    for (let i = 0; i < nr_rows; i++) {
                        DOM.add_row();
                    }
                },

                add_block: function(row, column, color) {
                    // add block to field and DOM
                    field.field[row][column] = true;
                    field.print_field_to_DOM();
                },

                remove_block: function(row, column) {
                    // remove block from field and DOM
                    field.field[row][column] = false;
                    field.print_field_to_DOM();
                },

                validate_cell: function(row, column) {
                    if (row >= nr_rows || row < 0 || column >= nr_columns || column < 0) {
                        // cell is outside the field
                        return false;
                    }
                    if (field.field[row][column] === true) {
                        // cell is already occupied
                        return false;
                    } else {
                        // cell is available
                        return true;
                    }
                },

                validate_fullrow: function(row) {
                    for (let column = 0; column < nr_columns; column++) {
                        if (field.field[row][column] != true) {
                            // note: cells can be true, false, or undefined
                            return false;
                        }
                    }
                    return true;
                },

                remove_row: function(row) {
                    // NOTE: only remove a row if there is no acitve block!
                    // remove row from field
                    field.field.splice(row, 1);
                    // add clean row to top of field
                    field.field.unshift(new Array(nr_columns));

                    // update DOM
                    DOM.remove_row(row);
                    DOM.add_row();
                },

                print_field_to_DOM: function() {
                    for (let row = 0; row < nr_rows; row++) {
                        let DOM_row = document.querySelectorAll("tr")[row];
                        for (let column = 0; column < nr_columns; column++) {
                            let DOM_block = DOM_row.querySelectorAll("td")[column];
                            if (field.field[row][column] === true) {
                                DOM_block.setAttribute("bgcolor", "red");
                            } else {
                                DOM_block.removeAttribute("bgcolor");
                            }
                        }
                    }
                }
            };

            // active block
            let active_block = {
                spawn: function(row, column, color) {
                    active_block.row = row;
                    active_block.column = column;
                    active_block.color = color;
                    field.add_block(row, column, color);
                },

                find_max_jumpdistance: function() {
                    let jumpdistance = 0;
                    let column = active_block.column;
                    let row = active_block.row + 1;
                    while (field.validate_cell(row, column) === true) {
                        jumpdistance += 1;
                        row += 1;
                    }
                    return jumpdistance;
                },

                move: function(delta_row, delta_column) {
                    const new_row = active_block.row + delta_row;
                    const new_column = active_block.column + delta_column;
                    const current_row = active_block.row;
                    const current_column = active_block.column;

                    // check if move is legal
                    if (field.validate_cell(new_row, new_column)) {
                        // update position of active block
                        active_block.row = new_row;
                        active_block.column = new_column;

                        // update field & DOM
                        field.remove_block(current_row, current_column);
                        field.add_block(new_row, new_column, active_block.color);

                        // check cell below the block to see if the block gets fixed
                        if (field.validate_cell(new_row + 1, new_column) === false) {
                            // the block is fixed

                            // check if the fixed block created a fullrow
                            if (field.validate_fullrow(active_block.row)) {
                                field.remove_row(active_block.row);
                            }

                            // spawn a new active block!
                            active_block.spawn(0, 4, "red");
                        }
                    }
                }
            };

            // DOM represenation functions
            const DOM = {
                add_row: function() {
                    let newRow = tetris_table.insertRow(0);
                    for (j = 0; j < nr_columns; j++) {
                        newRow.insertCell(0);
                    }
                },

                remove_row: function(row) {
                    document.querySelectorAll("tr")[row].remove();
                }
            };

            // start game
            field.spawn();
            active_block.spawn(0, 4, "red");

            // periodcially drop the active block
            window.setInterval(active_block.move, drop_speed, 1, 0);

            // event listeners:
            window.addEventListener("keyup", function(e) {
                // press space-bar (= 32) for maximal drop
                if (e.keyCode === 32) {
                    const jumpdistance = active_block.find_max_jumpdistance();
                    if (jumpdistance > 0) {
                        active_block.move(jumpdistance, 0);
                    }
                }

                // left: 37
                if (e.keyCode === 37) {
                    active_block.move(0, -1);
                }

                // right: 39
                if (e.keyCode === 39) {
                    active_block.move(0, 1);
                }

                // up: 38
                if (e.keyCode === 38) {
                    active_block.move(-1, 0);
                }

                // down: 40
                if (e.keyCode === 40) {
                    active_block.move(1, 0);
                }
            });
        </script>
    </body>
</html>
